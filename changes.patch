diff --git a/src/main.rs b/src/main.rs
index 9adf44a..7c4f080 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,12 +1,11 @@
 use iced::{
     executor,
-    widget::{button, column, container, row, scrollable, text, Column, Container},
+    widget::{button, column, container, row, text},
     Application, Command, Element, Length, Settings, Theme,
 };
 use std::path::PathBuf;
 use tracing::{info, debug};
 use image::DynamicImage;
-use anyhow::Result;
 
 mod photo;
 mod ui;
@@ -26,7 +25,8 @@ pub fn main() -> iced::Result {
 
 #[derive(Debug)]
 struct PhotoFlow {
-    photos: Vec<Photo>,
+    photo_paths: Vec<PathBuf>,
+    photos: Vec<Option<Photo>>,
     current_photo: Option<usize>,
     photo_view: PhotoView,
     error: Option<String>,
@@ -52,6 +52,7 @@ impl Application for PhotoFlow {
     fn new(_flags: ()) -> (Self, Command<Message>) {
         (
             Self {
+                photo_paths: Vec::new(),
                 photos: Vec::new(),
                 current_photo: None,
                 photo_view: PhotoView::new(),
@@ -102,30 +103,41 @@ impl Application for PhotoFlow {
             Message::DirectoryLoaded(paths) => {
                 debug!("Directory loaded with {} paths", paths.len());
                 self.error = None;
-                let photos: Vec<_> = paths
-                    .iter()
-                    .filter_map(|path| {
-                        debug!("Attempting to load photo: {}", path.display());
-                        Photo::new(path.clone()).ok()
-                    })
-                    .collect();
                 
-                if !photos.is_empty() {
-                    self.photos = photos;
+                if !paths.is_empty() {
+                    // Store paths and initialize photos vector with None
+                    let paths_len = paths.len();
+                    let first_path = paths[0].clone();
+                    self.photo_paths = paths;
+                    self.photos = vec![None; paths_len];
                     self.current_photo = Some(0);
                     
-                    // Load the first image
-                    if let Some(photo) = self.photos.first() {
-                        let path = photo.path().to_path_buf();
-                        let path_clone = path.clone();
-                        let photo_clone = photo.clone();
-                        return Command::perform(
-                            async move { photo_clone.load_image() },
-                            move |result| Message::ImageLoaded(path_clone, result.ok())
-                        );
-                    }
-                } else if !paths.is_empty() {
-                    self.error = Some("No valid photos found in directory".to_string());
+                    // Load only the first photo
+                    let first_path_clone = first_path.clone();
+                    return Command::perform(
+                        async move {
+                            match Photo::new(first_path.clone()) {
+                                Ok(mut photo) => {
+                                    if let Ok(image) = photo.load_image() {
+                                        photo.set_image(image);
+                                        Some(photo)
+                                    } else {
+                                        None
+                                    }
+                                },
+                                Err(_) => None
+                            }
+                        },
+                        move |result| {
+                            if let Some(photo) = result {
+                                Message::ImageLoaded(first_path_clone, photo.image)
+                            } else {
+                                Message::Error(format!("Failed to load image: {}", first_path_clone.display()))
+                            }
+                        }
+                    );
+                } else {
+                    self.error = Some("No photos found in directory".to_string());
                 }
                 
                 Command::none()
@@ -133,29 +145,68 @@ impl Application for PhotoFlow {
             Message::PhotoSelected(index) => {
                 if index < self.photos.len() {
                     self.current_photo = Some(index);
-                    let photo = &self.photos[index];
-                    let path = photo.path().to_path_buf();
-                    let path_clone = path.clone();
-                    let photo_clone = photo.clone();
-                    return Command::perform(
-                        async move { photo_clone.load_image() },
-                        move |result| Message::ImageLoaded(path_clone, result.ok())
-                    );
+                    
+                    // If photo isn't loaded yet, load it
+                    if self.photos[index].is_none() {
+                        let path = self.photo_paths[index].clone();
+                        let path_clone = path.clone();
+                        return Command::perform(
+                            async move {
+                                match Photo::new(path.clone()) {
+                                    Ok(mut photo) => {
+                                        if let Ok(image) = photo.load_image() {
+                                            photo.set_image(image.clone());
+                                            Some((photo, image))
+                                        } else {
+                                            None
+                                        }
+                                    },
+                                    Err(_) => None
+                                }
+                            },
+                            move |result| {
+                                if let Some((photo, image)) = result {
+                                    Message::ImageLoaded(path_clone, Some(image))
+                                } else {
+                                    Message::Error(format!("Failed to load image: {}", path_clone.display()))
+                                }
+                            }
+                        );
+                    }
                 }
                 Command::none()
             }
             Message::NextPhoto => {
                 if let Some(current) = self.current_photo {
                     if current + 1 < self.photos.len() {
-                        self.current_photo = Some(current + 1);
-                        let photo = &self.photos[current + 1];
-                        let path = photo.path().to_path_buf();
-                        let path_clone = path.clone();
-                        let photo_clone = photo.clone();
-                        return Command::perform(
-                            async move { photo_clone.load_image() },
-                            move |result| Message::ImageLoaded(path_clone, result.ok())
-                        );
+                        let next = current + 1;
+                        if self.photos[next].is_none() {
+                            let path = self.photo_paths[next].clone();
+                            let path_clone = path.clone();
+                            return Command::perform(
+                                async move {
+                                    match Photo::new(path.clone()) {
+                                        Ok(mut photo) => {
+                                            if let Ok(image) = photo.load_image() {
+                                                photo.set_image(image);
+                                                Some(photo)
+                                            } else {
+                                                None
+                                            }
+                                        },
+                                        Err(_) => None
+                                    }
+                                },
+                                move |result| {
+                                    if let Some(photo) = result {
+                                        Message::ImageLoaded(path_clone, photo.image)
+                                    } else {
+                                        Message::Error(format!("Failed to load image: {}", path_clone.display()))
+                                    }
+                                }
+                            );
+                        }
+                        self.current_photo = Some(next);
                     }
                 }
                 Command::none()
@@ -164,14 +215,32 @@ impl Application for PhotoFlow {
                 if let Some(current) = self.current_photo {
                     if current > 0 {
                         self.current_photo = Some(current - 1);
-                        let photo = &self.photos[current - 1];
-                        let path = photo.path().to_path_buf();
-                        let path_clone = path.clone();
-                        let photo_clone = photo.clone();
-                        return Command::perform(
-                            async move { photo_clone.load_image() },
-                            move |result| Message::ImageLoaded(path_clone, result.ok())
-                        );
+                        if self.photos[current - 1].is_none() {
+                            let path = self.photo_paths[current - 1].clone();
+                            let path_clone = path.clone();
+                            return Command::perform(
+                                async move {
+                                    match Photo::new(path.clone()) {
+                                        Ok(mut photo) => {
+                                            if let Ok(image) = photo.load_image() {
+                                                photo.set_image(image);
+                                                Some(photo)
+                                            } else {
+                                                None
+                                            }
+                                        },
+                                        Err(_) => None
+                                    }
+                                },
+                                move |result| {
+                                    if let Some(photo) = result {
+                                        Message::ImageLoaded(path_clone, photo.image)
+                                    } else {
+                                        Message::Error(format!("Failed to load image: {}", path_clone.display()))
+                                    }
+                                }
+                            );
+                        }
                     }
                 }
                 Command::none()
@@ -183,14 +252,20 @@ impl Application for PhotoFlow {
             }
             Message::ImageLoaded(path, image) => {
                 debug!("Image loaded: {}", path.display());
-                if let Some(image) = image {
-                    // Find the photo with matching path and update it
-                    if let Some(photo) = self.photos.iter_mut().find(|p| p.path() == path) {
-                        photo.set_image(image);
+                if let Some(index) = self.photo_paths.iter().position(|p| p == &path) {
+                    // Create new photo if it doesn't exist
+                    if self.photos[index].is_none() {
+                        if let Ok(mut photo) = Photo::new(path.clone()) {
+                            if let Some(img) = image {
+                                photo.set_image(img);
+                            }
+                            self.photos[index] = Some(photo);
+                        }
+                    } else if let Some(photo) = &mut self.photos[index] {
+                        if let Some(img) = image {
+                            photo.set_image(img);
+                        }
                     }
-                } else {
-                    info!("Failed to load image: {}", path.display());
-                    self.error = Some(format!("Failed to load image: {}", path.display()));
                 }
                 Command::none()
             }
@@ -198,6 +273,9 @@ impl Application for PhotoFlow {
     }
 
     fn view(&self) -> Element<Message> {
+        let current_photo = self.current_photo
+            .and_then(|i| self.photos[i].as_ref());
+        
         let controls = row![
             button("Previous").on_press(Message::PreviousPhoto),
             button("Load Directory").on_press(Message::LoadDirectory),
@@ -205,14 +283,10 @@ impl Application for PhotoFlow {
         ]
         .spacing(10);
 
-        let content = if let Some(current) = self.current_photo {
-            if let Some(photo) = self.photos.get(current) {
-                self.photo_view.view(photo)
-            } else {
-                text("No photo selected").into()
-            }
+        let content = if let Some(photo) = current_photo {
+            self.photo_view.view(photo)
         } else {
-            text("No photos loaded").into()
+            text("No photo selected").into()
         };
 
         let error_text = if let Some(error) = &self.error {
diff --git a/src/photo.rs b/src/photo.rs
index fd2d7db..8fb4aef 100644
--- a/src/photo.rs
+++ b/src/photo.rs
@@ -1,18 +1,28 @@
 use std::path::{Path, PathBuf};
-use anyhow::{Context, Result};
+use std::sync::Arc;
+use anyhow::Result;
 use image::DynamicImage;
 use exif::{Reader, Tag, Value};
 use std::fs::File;
 use std::io::BufReader;
-use tracing::{debug, error, info};
+use tracing::{debug, info};
+use std::time::SystemTime;
+use lru::LruCache;
+use parking_lot::Mutex;
+use once_cell::sync::Lazy;
 
 use crate::processors;
 
+// Cache for loaded images
+static IMAGE_CACHE: Lazy<Arc<Mutex<LruCache<PathBuf, (DynamicImage, SystemTime)>>>> = 
+    Lazy::new(|| Arc::new(Mutex::new(LruCache::new(std::num::NonZeroUsize::new(32).unwrap())))); // Cache up to 32 images
+
 #[derive(Debug, Clone)]
 pub struct Photo {
     path: PathBuf,
     exif_data: Option<ExifData>,
     pub image: Option<DynamicImage>,
+    rgb_data: Option<Vec<u8>>,
 }
 
 #[derive(Debug, Clone)]
@@ -32,6 +42,7 @@ impl Photo {
             path,
             exif_data: None,
             image: None,
+            rgb_data: None,
         };
         
         if let Err(e) = photo.load_exif() {
@@ -50,22 +61,75 @@ impl Photo {
     }
 
     pub fn set_image(&mut self, image: DynamicImage) {
+        // Convert to RGB8 once and cache it
+        let rgb = image.to_rgb8();
+        self.rgb_data = Some(rgb.to_vec());
         self.image = Some(image);
     }
 
+    pub fn get_rgb_data(&self) -> Vec<u8> {
+        if let Some(data) = &self.rgb_data {
+            data.clone()
+        } else if let Some(img) = &self.image {
+            let rgb = img.to_rgb8();
+            rgb.to_vec()
+        } else {
+            Vec::new()
+        }
+    }
+
     pub fn load_image(&self) -> Result<DynamicImage> {
         info!("Loading image: {}", self.path.display());
         
-        // Get appropriate processor for this file type
+        // Try to load from cache first
+        if let Some((cached_image, cached_time)) = IMAGE_CACHE.lock().get(&self.path).cloned() {
+            // Check if file has been modified
+            if let Ok(metadata) = std::fs::metadata(&self.path) {
+                if let Ok(modified) = metadata.modified() {
+                    if modified <= cached_time {
+                        debug!("Loading image from cache: {}", self.path.display());
+                        return Ok(cached_image);
+                    }
+                }
+            }
+        }
+        
+        // Not in cache, load using processor
         let processor = processors::get_processor(&self.path);
+        let image = processor.load_image(&self.path)?;
+        
+        // Add to cache
+        if let Ok(metadata) = std::fs::metadata(&self.path) {
+            if let Ok(modified) = metadata.modified() {
+                IMAGE_CACHE.lock().put(self.path.clone(), (image.clone(), modified));
+            }
+        }
         
-        // Load the image using the processor
-        processor.load_image(&self.path)
+        Ok(image)
     }
 
 
     fn load_exif(&mut self) -> Result<()> {
-        debug!("Loading EXIF data from: {:?}", self.path);
+        debug!("Loading metadata from: {:?}", self.path);
+        
+        // First try to load metadata from rawloader for RAW files
+        if let Ok(raw_image) = rawloader::decode_file(&self.path) {
+            debug!("Got metadata from rawloader");
+            let data = ExifData {
+                make: Some(raw_image.make),
+                model: Some(raw_image.model),
+                exposure_time: None, // TODO: Add these from rawloader
+                f_number: None,
+                iso: None,
+                focal_length: None,
+                datetime: None,
+            };
+            self.exif_data = Some(data);
+            return Ok(());
+        }
+        
+        // Fall back to EXIF for non-RAW files
+        debug!("Falling back to EXIF parser");
         let file = File::open(&self.path)?;
         let mut bufreader = BufReader::new(&file);
         let exif = Reader::new().read_from_container(&mut bufreader)?;
diff --git a/src/processors/detector.rs b/src/processors/detector.rs
index 5ac843f..c72aeac 100644
--- a/src/processors/detector.rs
+++ b/src/processors/detector.rs
@@ -1,9 +1,12 @@
 use std::path::Path;
 use std::fs::File;
 use std::io::{Read, Seek, SeekFrom};
-use anyhow::{Context, Result};
+use anyhow::{Result, Context};
 use tracing::debug;
 
+// Size threshold for using memory mapping (32MB)
+const MMAP_THRESHOLD: u64 = 32 * 1024 * 1024;
+
 #[derive(Debug, PartialEq)]
 pub enum ImageType {
     Jpeg,
@@ -37,7 +40,6 @@ impl ImageType {
 pub fn detect_image_type(path: &Path) -> Result<ImageType> {
     let mut file = File::open(path).context("Failed to open file for type detection")?;
     let mut buffer = [0u8; 16]; // Most magic numbers are within first 16 bytes
-    
     file.read_exact(&mut buffer).context("Failed to read file header")?;
     
     // First check for common image formats
@@ -62,7 +64,23 @@ pub fn detect_image_type(path: &Path) -> Result<ImageType> {
     }
     
     // Check for TIFF (both little and big endian)
-    if (&buffer[0..4] == b"MM\x00*" || &buffer[0..4] == b"II*\x00") {
+    if &buffer[0..4] == b"MM\x00*" || &buffer[0..4] == b"II*\x00" {
+        // Need to check deeper in the file for Nikon specific markers
+        let mut extended_buffer = [0u8; 4096];
+        file.seek(SeekFrom::Start(0))?;
+        file.read_exact(&mut extended_buffer)?;
+        
+        if extended_buffer.windows(4).any(|window| window == b"NIKON") {
+            debug!("Detected Nikon NEF format");
+            return Ok(ImageType::RawNikon);
+        }
+        
+        // Check for Panasonic RW2
+        if extended_buffer.windows(4).any(|window| window == b"PANA") {
+            debug!("Detected Panasonic RW2 format");
+            return Ok(ImageType::RawPanasonic);
+        }
+        
         debug!("Detected TIFF format");
         return Ok(ImageType::Tiff);
     }
@@ -81,31 +99,12 @@ pub fn detect_image_type(path: &Path) -> Result<ImageType> {
         return Ok(ImageType::RawCanon);
     }
     
-    // Nikon NEF (usually starts with TIFF header)
-    if (&buffer[0..4] == b"MM\x00*" || &buffer[0..4] == b"II*\x00") {
-        // Need to check deeper in the file for Nikon specific markers
-        let mut extended_buffer = [0u8; 4096];
-        file.seek(SeekFrom::Start(0))?;
-        file.read_exact(&mut extended_buffer)?;
-        
-        if extended_buffer.windows(4).any(|window| window == b"NIKON") {
-            debug!("Detected Nikon NEF format");
-            return Ok(ImageType::RawNikon);
-        }
-    }
-    
     // Sony ARW
     if &buffer[0..4] == b"SONY" {
         debug!("Detected Sony ARW format");
         return Ok(ImageType::RawSony);
     }
     
-    // Panasonic RW2
-    if &buffer[0..4] == b"IIU\x00" {
-        debug!("Detected Panasonic RW2 format");
-        return Ok(ImageType::RawPanasonic);
-    }
-    
     // Generic RAW check (look for common RAW markers)
     let raw_markers = [
         b"CIFF", // Canon old format
diff --git a/src/processors/mod.rs b/src/processors/mod.rs
index 059cec8..c23b390 100644
--- a/src/processors/mod.rs
+++ b/src/processors/mod.rs
@@ -1,6 +1,8 @@
 pub mod raw;
 pub mod standard;
 pub mod detector;
+#[cfg(test)]
+mod tests;
 
 use std::path::Path;
 use anyhow::Result;
diff --git a/src/processors/raw.rs b/src/processors/raw.rs
index 0bdd183..715bd7d 100644
--- a/src/processors/raw.rs
+++ b/src/processors/raw.rs
@@ -4,6 +4,7 @@ use image::DynamicImage;
 use rawloader::{decode_file, RawImageData};
 use tracing::{info, debug, error};
 
+use crate::photo::ExifData;
 use super::{ImageProcessor, detector::{self, ImageType}};
 
 pub struct RawProcessor;
@@ -49,47 +50,230 @@ impl ImageProcessor for RawProcessor {
         
         // Convert raw image data to RGB with format-specific adjustments
         info!("Converting RAW data to RGB...");
+        // Update EXIF data from rawloader metadata
+        let _exif = ExifData {
+            make: Some(raw_image.make.clone()),
+            model: Some(raw_image.model.clone()),
+            exposure_time: None, // TODO: Add these from rawloader
+            f_number: None,
+            iso: None,
+            focal_length: None,
+            datetime: None,
+        };
+        
         let rgb_data = match raw_image.data {
             RawImageData::Integer(data) => {
                 debug!("Converting integer RAW data");
                 let mut rgb = Vec::with_capacity(width as usize * height as usize * 3);
-                let max_value = data.iter().copied().max().unwrap_or(65535) as f32;
                 
-                // Apply gamma correction with format-specific adjustments
-                let gamma = match image_type {
-                    ImageType::RawFuji => 2.4,  // Fuji typically needs slightly higher gamma
-                    ImageType::RawCanon => 2.1, // Canon typically needs slightly lower gamma
-                    _ => 2.2,  // Standard gamma for other formats
-                };
+                // Get black and white levels
+                let black_level = raw_image.blacklevels[0] as f32;
+                let white_level = raw_image.whitelevels[0] as f32;
+                let range = white_level - black_level;
+                debug!("Black level: {}, White level: {}, Range: {}", black_level, white_level, range);
+                
+                // Get white balance coefficients
+                let wb_coeffs = raw_image.wb_coeffs;
+                debug!("WB coeffs: R={}, G={}, B={}", wb_coeffs[0], wb_coeffs[1], wb_coeffs[2]);
+                
+                // Get CFA pattern info
+                let cfa = raw_image.cfa.clone();
+                debug!("CFA pattern: width={}, height={}", cfa.width, cfa.height);
+                debug!("CFA pattern string: {}", raw_image.cfa.name);
                 
-                for value in data {
-                    // Convert to 8-bit with gamma correction
-                    let normalized = (value as f32 / max_value).powf(1.0 / gamma);
-                    let v = (normalized * 255.0) as u8;
-                    rgb.extend_from_slice(&[v, v, v]);
+                // Sample some raw values
+                debug!("Raw value samples:");
+                for y in [0, height as usize / 2, height as usize - 1] {
+                    for x in [0, width as usize / 2, width as usize - 1] {
+                        let pixel_idx = y * width as usize + x;
+                        let raw_value = data[pixel_idx];
+                        debug!("  ({}, {}): {}", x, y, raw_value);
+                    }
                 }
-                rgb
-            },
-            RawImageData::Float(data) => {
-                debug!("Converting float RAW data");
-                let mut rgb = Vec::with_capacity(width as usize * height as usize * 3);
-                let max_value = data.iter().copied().fold(0.0, f32::max);
                 
-                // Apply gamma correction with format-specific adjustments
-                let gamma = match image_type {
-                    ImageType::RawFuji => 2.4,
-                    ImageType::RawCanon => 2.1,
-                    _ => 2.2,
-                };
+                // Create buffers for each color channel
+                let mut red = vec![0.0f32; (width * height) as usize];
+                let mut green = vec![0.0f32; (width * height) as usize];
+                let mut blue = vec![0.0f32; (width * height) as usize];
+                
+                // First pass: Fill in known values
+                for y in 0..height as usize {
+                    for x in 0..width as usize {
+                        let pixel_idx = y * width as usize + x;
+                        let raw_value = data[pixel_idx] as f32;
+                        
+                        // Normalize value using black and white levels
+                        let mut normalized = (raw_value - black_level) / range;
+                        normalized = normalized.clamp(0.0, 1.0);
+                        
+                        // For X-Trans sensors, the pattern repeats every 6x6 pixels
+                        let cfa_x = x % 6;
+                        let cfa_y = y % 6;
+                        
+                        // X-Trans pattern (0=R, 1=G, 2=B)
+                        let color = match (cfa_x, cfa_y) {
+                            // Row 0
+                            (0, 0) => 2, (1, 0) => 1, (2, 0) => 1, (3, 0) => 2, (4, 0) => 1, (5, 0) => 1,
+                            // Row 1
+                            (0, 1) => 1, (1, 1) => 2, (2, 1) => 0, (3, 1) => 1, (4, 1) => 0, (5, 1) => 2,
+                            // Row 2
+                            (0, 2) => 1, (1, 2) => 0, (2, 2) => 1, (3, 2) => 2, (4, 2) => 1, (5, 2) => 0,
+                            // Row 3
+                            (0, 3) => 2, (1, 3) => 1, (2, 3) => 1, (3, 3) => 2, (4, 3) => 1, (5, 3) => 1,
+                            // Row 4
+                            (0, 4) => 1, (1, 4) => 2, (2, 4) => 0, (3, 4) => 1, (4, 4) => 0, (5, 4) => 2,
+                            // Row 5
+                            (0, 5) => 1, (1, 5) => 0, (2, 5) => 1, (3, 5) => 2, (4, 5) => 1, (5, 5) => 0,
+                            _ => unreachable!()
+                        };
+                        
+                        // Apply white balance
+                        let wb_coeff = match color {
+                            0 => wb_coeffs[0], // Red
+                            1 => wb_coeffs[1], // Green
+                            2 => wb_coeffs[2], // Blue
+                            _ => 1.0,
+                        };
+                        
+                        let color_value = normalized * wb_coeff;
+                        
+                        // Store in appropriate channel
+                        match color {
+                            0 => red[pixel_idx] = color_value,
+                            1 => green[pixel_idx] = color_value,
+                            2 => blue[pixel_idx] = color_value,
+                            _ => {},
+                        }
+                    }
+                }
+                
+                // Sample some normalized values
+                debug!("Normalized value samples after first pass:");
+                for y in [0, height as usize / 2, height as usize - 1] {
+                    for x in [0, width as usize / 2, width as usize - 1] {
+                        let pixel_idx = y * width as usize + x;
+                        debug!("  ({}, {}): R={:.3}, G={:.3}, B={:.3}", 
+                            x, y, red[pixel_idx], green[pixel_idx], blue[pixel_idx]);
+                    }
+                }
+                
+                // Second pass: Simple bilinear interpolation for missing colors
+                for y in 1..(height as usize - 1) {
+                    for x in 1..(width as usize - 1) {
+                        let pixel_idx = y * width as usize + x;
+                        let cfa_x = x % cfa.width;
+                        let cfa_y = y % cfa.height;
+                        let color = cfa.color_at(cfa_x, cfa_y);
+                        
+                        // For each missing color at this pixel, average the neighbors
+                        match color {
+                            0 => { // Red pixel - interpolate G and B
+                                if green[pixel_idx] == 0.0 {
+                                    let neighbors = [
+                                        green[pixel_idx - 1],
+                                        green[pixel_idx + 1],
+                                        green[pixel_idx - width as usize],
+                                        green[pixel_idx + width as usize],
+                                    ];
+                                    let valid_count = neighbors.iter().filter(|&&v| v > 0.0).count();
+                                    if valid_count > 0 {
+                                        green[pixel_idx] = neighbors.iter().filter(|&&v| v > 0.0).sum::<f32>() / valid_count as f32;
+                                    }
+                                }
+                                if blue[pixel_idx] == 0.0 {
+                                    let neighbors = [
+                                        blue[pixel_idx - 1 - width as usize],
+                                        blue[pixel_idx - 1 + width as usize],
+                                        blue[pixel_idx + 1 - width as usize],
+                                        blue[pixel_idx + 1 + width as usize],
+                                    ];
+                                    let valid_count = neighbors.iter().filter(|&&v| v > 0.0).count();
+                                    if valid_count > 0 {
+                                        blue[pixel_idx] = neighbors.iter().filter(|&&v| v > 0.0).sum::<f32>() / valid_count as f32;
+                                    }
+                                }
+                            },
+                            1 => { // Green pixel - interpolate R and B
+                                if red[pixel_idx] == 0.0 {
+                                    let neighbors = [
+                                        red[pixel_idx - 1],
+                                        red[pixel_idx + 1],
+                                        red[pixel_idx - width as usize],
+                                        red[pixel_idx + width as usize],
+                                    ];
+                                    let valid_count = neighbors.iter().filter(|&&v| v > 0.0).count();
+                                    if valid_count > 0 {
+                                        red[pixel_idx] = neighbors.iter().filter(|&&v| v > 0.0).sum::<f32>() / valid_count as f32;
+                                    }
+                                }
+                                if blue[pixel_idx] == 0.0 {
+                                    let neighbors = [
+                                        blue[pixel_idx - 1],
+                                        blue[pixel_idx + 1],
+                                        blue[pixel_idx - width as usize],
+                                        blue[pixel_idx + width as usize],
+                                    ];
+                                    let valid_count = neighbors.iter().filter(|&&v| v > 0.0).count();
+                                    if valid_count > 0 {
+                                        blue[pixel_idx] = neighbors.iter().filter(|&&v| v > 0.0).sum::<f32>() / valid_count as f32;
+                                    }
+                                }
+                            },
+                            2 => { // Blue pixel - interpolate R and G
+                                if red[pixel_idx] == 0.0 {
+                                    let neighbors = [
+                                        red[pixel_idx - 1 - width as usize],
+                                        red[pixel_idx - 1 + width as usize],
+                                        red[pixel_idx + 1 - width as usize],
+                                        red[pixel_idx + 1 + width as usize],
+                                    ];
+                                    let valid_count = neighbors.iter().filter(|&&v| v > 0.0).count();
+                                    if valid_count > 0 {
+                                        red[pixel_idx] = neighbors.iter().filter(|&&v| v > 0.0).sum::<f32>() / valid_count as f32;
+                                    }
+                                }
+                                if green[pixel_idx] == 0.0 {
+                                    let neighbors = [
+                                        green[pixel_idx - 1],
+                                        green[pixel_idx + 1],
+                                        green[pixel_idx - width as usize],
+                                        green[pixel_idx + width as usize],
+                                    ];
+                                    let valid_count = neighbors.iter().filter(|&&v| v > 0.0).count();
+                                    if valid_count > 0 {
+                                        green[pixel_idx] = neighbors.iter().filter(|&&v| v > 0.0).sum::<f32>() / valid_count as f32;
+                                    }
+                                }
+                            },
+                            _ => {},
+                        }
+                    }
+                }
+                
+                // Sample some normalized values after interpolation
+                debug!("Normalized value samples after interpolation:");
+                for y in [0, height as usize / 2, height as usize - 1] {
+                    for x in [0, width as usize / 2, width as usize - 1] {
+                        let pixel_idx = y * width as usize + x;
+                        debug!("  ({}, {}): R={:.3}, G={:.3}, B={:.3}", 
+                            x, y, red[pixel_idx], green[pixel_idx], blue[pixel_idx]);
+                    }
+                }
                 
-                for value in data {
-                    // Convert to 8-bit with gamma correction
-                    let normalized = (value / max_value).powf(1.0 / gamma);
-                    let v = (normalized * 255.0) as u8;
-                    rgb.extend_from_slice(&[v, v, v]);
+                // Final pass: Convert to RGB bytes with gamma correction
+                let gamma = 2.2;
+                for i in 0..(width * height) as usize {
+                    let r = (red[i].powf(1.0 / gamma) * 255.0) as u8;
+                    let g = (green[i].powf(1.0 / gamma) * 255.0) as u8;
+                    let b = (blue[i].powf(1.0 / gamma) * 255.0) as u8;
+                    rgb.extend_from_slice(&[r, g, b]);
                 }
                 rgb
             },
+            RawImageData::Float(_data) => {
+                // Similar process for float data
+                vec![0; (width * height * 3) as usize] // TODO: Implement float handling
+            },
         };
         
         debug!("Creating RGB image from RAW data");
diff --git a/src/processors/standard.rs b/src/processors/standard.rs
index 0f5d623..fc2451e 100644
--- a/src/processors/standard.rs
+++ b/src/processors/standard.rs
@@ -1,7 +1,13 @@
 use std::path::Path;
 use anyhow::{Context, Result};
 use image::DynamicImage;
-use tracing::info;
+use tracing::{info, debug};
+use std::fs::File;
+use memmap2::Mmap;
+use std::io::BufReader;
+
+// Size threshold for using memory mapping (32MB)
+const MMAP_THRESHOLD: u64 = 32 * 1024 * 1024;
 
 use super::{ImageProcessor, detector::{self, ImageType}};
 
@@ -30,6 +36,20 @@ impl ImageProcessor for StandardProcessor {
     
     fn load_image(&self, path: &Path) -> Result<DynamicImage> {
         info!("Loading standard image: {}", path.display());
-        image::open(path).context("Failed to open image file")
+        
+        let file = File::open(path)?;
+        let metadata = file.metadata()?;
+        
+        // Use memory mapping for large files
+        if metadata.len() > MMAP_THRESHOLD {
+            debug!("Using memory mapping for large image: {} bytes", metadata.len());
+            let mmap = unsafe { Mmap::map(&file)? };
+            image::load_from_memory(&mmap).context("Failed to load image from memory map")
+        } else {
+            // Use buffered reader for smaller files
+            let reader = BufReader::new(file);
+            image::load(reader, image::ImageFormat::from_path(path)?)
+                .context("Failed to load image from file")
+        }
     }
 }
diff --git a/src/processors/tests.rs b/src/processors/tests.rs
new file mode 100644
index 0000000..86c883d
--- /dev/null
+++ b/src/processors/tests.rs
@@ -0,0 +1,54 @@
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::time::Instant;
+    use std::path::PathBuf;
+    use tracing::info;
+
+    fn setup_test_image(name: &str) -> PathBuf {
+        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
+            .join("test_data")
+            .join(name)
+    }
+
+    #[test]
+    fn test_image_loading_performance() {
+        // Initialize logging
+        let _ = tracing_subscriber::fmt::try_init();
+
+        // Test image paths
+        let jpeg_path = setup_test_image("test.jpg");
+        let raw_path = setup_test_image("test.raf");
+
+        // Test JPEG loading performance
+        info!("Testing JPEG loading performance...");
+        let start = Instant::now();
+        for _ in 0..5 {
+            let photo = Photo::new(&jpeg_path).expect("Failed to load JPEG");
+            assert!(photo.image.is_some());
+        }
+        let jpeg_time = start.elapsed();
+        info!("JPEG loading time (5 iterations): {:?}", jpeg_time);
+
+        // Test cache hit performance
+        info!("Testing cache hit performance...");
+        let start = Instant::now();
+        for _ in 0..5 {
+            let photo = Photo::new(&jpeg_path).expect("Failed to load JPEG");
+            assert!(photo.image.is_some());
+        }
+        let cache_time = start.elapsed();
+        info!("Cache hit time (5 iterations): {:?}", cache_time);
+        assert!(cache_time < jpeg_time, "Cache should be faster than loading from disk");
+
+        // Test RAW loading performance
+        if raw_path.exists() {
+            info!("Testing RAW loading performance...");
+            let start = Instant::now();
+            let photo = Photo::new(&raw_path).expect("Failed to load RAW");
+            assert!(photo.image.is_some());
+            let raw_time = start.elapsed();
+            info!("RAW loading time: {:?}", raw_time);
+        }
+    }
+}
diff --git a/src/ui.rs b/src/ui.rs
index 03e5bef..31e8a12 100644
--- a/src/ui.rs
+++ b/src/ui.rs
@@ -1,8 +1,6 @@
-use std::path::PathBuf;
-use std::fs;
-
 use iced::{
-    widget::{column, container, row, text, Column, Container, Image},
+    advanced::image::Handle,
+    widget::{column, container, text, Image},
     Element, Length,
 };
 
@@ -61,22 +59,12 @@ impl PhotoView {
 
         // Create the image widget
         let image_widget = if let Some(img) = &photo.image {
-            // Save the image to a temporary file
-            let temp_dir = std::env::temp_dir();
-            let temp_path = temp_dir.join(format!("photoflow_temp_{}.jpg", 
-                photo.path().file_name().unwrap_or_default().to_string_lossy()));
-            
-            if img.save(&temp_path).is_ok() {
-                Image::new(temp_path)
-                    .width(Length::Fill)
-                    .height(Length::Fill)
-            } else {
-                Image::new(PathBuf::new())
-                    .width(Length::Fill)
-                    .height(Length::Fill)
-            }
+            // The image should already be in RGB8 format
+            Image::new(Handle::from_memory(photo.get_rgb_data()))
+                .width(Length::Fill)
+                .height(Length::Fill)
         } else {
-            Image::new(PathBuf::new())
+            Image::new(Handle::from_memory(Vec::new()))
                 .width(Length::Fill)
                 .height(Length::Fill)
         };
